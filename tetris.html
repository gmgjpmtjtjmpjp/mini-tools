<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>ミニテトリス</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  body { font-family: system-ui, -apple-system, "Helvetica Neue", Arial; display:flex; gap:20px; padding:20px; background:#f0f0f3; }
  .game { display:flex; gap:20px; align-items:flex-start; }
  canvas { background:#111; image-rendering: pixelated; border-radius:6px; }
  .sidebar { color:#222; }
  .box { background:#fff; padding:12px; border-radius:8px; box-shadow:0 1px 3px rgba(0,0,0,0.08); }
  h1 { font-size:18px; margin:0 0 8px 0; }
  p { margin:6px 0; }
  button { padding:8px 12px; margin-top:6px; border-radius:6px; border:1px solid #ccc; background:white; }
  .small { font-size:13px; color:#555; }
  .controls { margin-top:10px; display:flex; gap:8px; flex-wrap:wrap; }
</style>
</head>
<body>
<div class="game">
  <div class="box">
    <h1>ミニテトリス</h1>
    <canvas id="board" width="200" height="400" style="width:200px;height:400px"></canvas>
    <div class="controls small">
      <div>操作： ← → ↓ 回転: ↑ / X / Z   ハードドロップ: Space</div>
    </div>
  </div>

  <div class="sidebar">
    <div class="box">
      <p><strong>スコア</strong></p>
      <div id="score" style="font-size:24px">0</div>
      <p class="small">レベル：<span id="level">1</span></p>
      <p class="small">ライン：<span id="lines">0</span></p>
      <button id="startBtn">スタート</button>
      <button id="pauseBtn">一時停止</button>
    </div>

    <div class="box" style="margin-top:12px;">
      <p><strong>次のピース</strong></p>
      <canvas id="next" width="120" height="120" style="width:120px;height:120px"></canvas>
    </div>

    <div class="box" style="margin-top:12px;">
      <p class="small">簡単なルール：横一列がそろうと消えます。スコアは消したライン数で増えます。</p>
    </div>
  </div>
</div>

<script>
// シンプルなテトリス実装（単一ファイル）
const COLS = 10;
const ROWS = 20;
const BLOCK = 20; // px
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
canvas.width = COLS * BLOCK;
canvas.height = ROWS * BLOCK;

const nextCanvas = document.getElementById('next');
const nctx = nextCanvas.getContext('2d');

const SHAPES = {
  I: [[1,1,1,1]],
  O: [[1,1],[1,1]],
  T: [[0,1,0],[1,1,1]],
  S: [[0,1,1],[1,1,0]],
  Z: [[1,1,0],[0,1,1]],
  J: [[1,0,0],[1,1,1]],
  L: [[0,0,1],[1,1,1]]
};
const COLORS = {
  I: '#00e0ff', O: '#ffd500', T: '#a000ff',
  S: '#00d000', Z:'#ff3b3b', J:'#0040ff', L:'#ff8c00'
};

function rotate(matrix){
  const N = matrix.length;
  const res = Array.from({length:N}, ()=>Array(N).fill(0));
  for(let r=0;r<N;r++) for(let c=0;c<N;c++) res[c][N-1-r]=matrix[r][c];
  return res;
}

function padSquare(mat){
  const n = Math.max(mat.length, mat[0].length);
  const out = Array.from({length:n}, ()=>Array(n).fill(0));
  for(let r=0;r<mat.length;r++) for(let c=0;c<mat[0].length;c++) out[r][c]=mat[r][c];
  return out;
}

function createMatrix(w,h){ const m=[]; for(let y=0;y<h;y++) m.push(Array(w).fill(0)); return m; }

function randomPiece(){
  const keys = Object.keys(SHAPES);
  const k = keys[Math.floor(Math.random()*keys.length)];
  return { shape:k, matrix: padSquare(SHAPES[k].map(r=>r.slice())), x: Math.floor((COLS - Math.max(SHAPES[k][0].length, SHAPES[k].length))/2), y:0 };
}

let board = createMatrix(COLS, ROWS);
function drawBlock(x,y,color){
  ctx.fillStyle = color;
  ctx.fillRect(x*BLOCK, y*BLOCK, BLOCK, BLOCK);
  ctx.strokeStyle = '#111';
  ctx.strokeRect(x*BLOCK, y*BLOCK, BLOCK, BLOCK);
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++) if(board[y][x]) drawBlock(x,y, board[y][x]);
  if(player.matrix){
    const n = player.matrix.length;
    for(let r=0;r<n;r++) for(let c=0;c<n;c++) if(player.matrix[r][c]){
      drawBlock(player.x + c, player.y + r, COLORS[player.shape]);
    }
  }
}

function drawNext(next){
  nctx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
  const size = BLOCK;
  const mat = next.matrix;
  const n = mat.length;
  const cellsX = nextCanvas.width/size;
  const cellsY = nextCanvas.height/size;
  const offsetX = Math.floor((cellsX - n)/2) * size;
  const offsetY = Math.floor((cellsY - n)/2) * size;
  for(let r=0;r<n;r++) for(let c=0;c<n;c++) if(mat[r][c]){
    nctx.fillStyle = COLORS[next.shape];
    nctx.fillRect(offsetX + c*size + 2, offsetY + r*size + 2, size-4, size-4);
    nctx.strokeStyle = '#222';
    nctx.strokeRect(offsetX + c*size + 2, offsetY + r*size + 2, size-4, size-4);
  }
}

function collide(mat,pos){
  for(let r=0;r<mat.length;r++) for(let c=0;c<mat.length;c++) if(mat[r][c]){
    const x = pos.x + c, y = pos.y + r;
    if(x<0 || x>=COLS || y>=ROWS) return true;
    if(y>=0 && board[y][x]) return true;
  }
  return false;
}

function merge(mat,pos,key){
  for(let r=0;r<mat.length;r++) for(let c=0;c<mat.length;c++) if(mat[r][c]){
    const x=pos.x+c, y=pos.y+r;
    if(y>=0) board[y][x] = COLORS[key];
  }
}

function sweep(){
  let lines=0;
  outer: for(let y=ROWS-1;y>=0;y--){
    for(let x=0;x<COLS;x++) if(!board[y][x]) continue outer;
    board.splice(y,1);
    board.unshift(Array(COLS).fill(0));
    lines++; y++;
  }
  return lines;
}

let player = randomPiece();
let nextPiece = randomPiece();
let dropCounter = 0;
let dropInterval = 1000;
let lastTime = 0;
let score = 0;
let level = 1;
let totalLines = 0;
let running = false;
let paused = false;

function reset(){
  board = createMatrix(COLS, ROWS);
  player = randomPiece();
  nextPiece = randomPiece();
  score = 0; level = 1; totalLines = 0;
  dropInterval = 1000; updateScore(); draw(); drawNext(nextPiece);
}

function playerDrop(){
  player.y++;
  if(collide(player.matrix, player)){
    player.y--;
    merge(player.matrix, player, player.shape);
    const lines = sweep();
    if(lines>0){
      totalLines += lines;
      score += [0,40,100,300,1200][lines] * level;
      level = Math.floor(totalLines/10)+1;
      dropInterval = Math.max(100, 1000 - (level-1)*100);
    }
    updateScore();
    player = nextPiece;
    nextPiece = randomPiece();
    player.x = Math.floor((COLS - player.matrix.length)/2);
    player.y = 0;
    if(collide(player.matrix, player)){
      running = false;
      setTimeout(()=>alert('ゲームオーバー！ スコア: ' + score),10);
      reset();
    }
    drawNext(nextPiece);
  }
}

function playerMove(dir){
  player.x += dir;
  if(collide(player.matrix, player)) player.x -= dir;
}

function playerRotate(dir){
  const old = player.matrix;
  player.matrix = rotate(player.matrix);
  if(dir<0){ player.matrix = rotate(player.matrix); player.matrix = rotate(player.matrix); }
  let offset = 1;
  while(collide(player.matrix, player)){
    player.x += offset;
    offset = -(offset + (offset>0?1:-1));
    if(Math.abs(offset) > player.matrix.length){ player.matrix = old; return; }
  }
}

function hardDrop(){
  while(!collide(player.matrix, player)) player.y++;
  player.y--;
  playerDrop();
  updateScore();
}

function update(time=0){
  const delta = time - lastTime;
  lastTime = time;
  if(!running || paused){ lastTime = time; requestAnimationFrame(update); return; }
  dropCounter += delta;
  if(dropCounter > dropInterval){
    playerDrop(); dropCounter = 0;
  }
  draw();
  requestAnimationFrame(update);
}

function updateScore(){
  document.getElementById('score').textContent = score;
  document.getElementById('level').textContent = level;
  document.getElementById('lines').textContent = totalLines;
}

document.addEventListener('keydown', e=>{
  if(e.key === 'ArrowLeft') { if(running) playerMove(-1); }
  else if(e.key === 'ArrowRight') { if(running) playerMove(1); }
  else if(e.key === 'ArrowDown') { if(running) playerDrop(); }
  else if(e.key === ' '){ e.preventDefault(); if(running) hardDrop(); }
  else if(e.key === 'ArrowUp' || e.key.toLowerCase()==='x' || e.key.toLowerCase()==='z'){ if(running) playerRotate(1); }
  draw();
});

document.getElementById('startBtn').addEventListener('click', ()=>{
  if(!running){ running = true; paused = false; lastTime = performance.now(); update(); }
});
document.getElementById('pauseBtn').addEventListener('click', ()=>{
  if(!running) return;
  paused = !paused;
  document.getElementById('pauseBtn').textContent = paused ? '再開' : '一時停止';
});

reset();
draw();
drawNext(nextPiece);
</script>
</body>
</html>
